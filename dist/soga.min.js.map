{"version":3,"file":"soga.min.js","sources":["../src/parseResponse.ts","../src/createResponse.ts","../src/setRequestHeaders.ts","../src/AjaxUploader.ts","../src/fetch.ts"],"sourcesContent":["import createResponse from './createResponse'\n\nexport default function (xhr: XMLHttpRequest) {\n\n  const keys: string[] = []\n  const values: string[] = []\n  const entries: string[][] = []\n\n  xhr\n    .getAllResponseHeaders()\n    .replace(\n      /^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm,\n      function (match: string, key: string, value: string) {\n        keys.push(key = key.toLowerCase())\n        values.push(value)\n        entries.push([key, value])\n        return match\n      }\n    )\n\n  return createResponse(xhr, keys, values, entries)\n\n}","import * as type from './type'\n\nexport default function (\n  xhr: XMLHttpRequest,\n  keys: string[],\n  values: string[],\n  entries: string[][]\n) {\n  function response(): type.Response {\n    return {\n      // 200-299\n      ok: (xhr.status / 100 | 0) == 2,\n      statusText: xhr.statusText,\n      status: xhr.status,\n      url: xhr.responseURL,\n      headers: {\n        keys() {\n          return keys\n        },\n        values() {\n          return values\n        },\n        entries() {\n          return entries\n        }\n      },\n      text() {\n        return xhr.responseText\n      },\n      json() {\n        return JSON.parse(xhr.responseText)\n      },\n      blob() {\n        return new Blob([xhr.response])\n      },\n      clone: response,\n    }\n  }\n  return response\n}","export default function (xhr: XMLHttpRequest, headers?: HeadersInit) {\n  for (let key in headers) {\n    xhr.setRequestHeader(key, headers[key])\n  }\n}","import * as type from './type'\nimport parseResponse from './parseResponse'\nimport setRequestHeaders from './setRequestHeaders'\n\nconst blobSlice = File.prototype['mozSlice'] || File.prototype['webkitSlice'] || File.prototype.slice\n\nexport default class AjaxUploader implements type.Uploader {\n\n  xhr: XMLHttpRequest\n\n  file: File\n  fileSize: number\n\n  hooks: type.UploadHooks\n\n  chunkInfo?: type.ChunkInfo\n\n  public static support() {\n    const xhr = new XMLHttpRequest()\n    return xhr && 'upload' in xhr && 'onprogress' in xhr.upload\n  }\n\n  constructor(file: File, hooks: type.UploadHooks) {\n\n    const instance = this\n\n    instance.file = file\n    instance.hooks = hooks\n\n    // 碰到过传了几个分片之后，file.size 变成 0 的情况\n    // 因此先存一下最初的 fileSize\n    instance.fileSize = file.size || 0\n\n    const xhr = instance.xhr = new XMLHttpRequest()\n\n    xhr.onloadstart = function () {\n      if (hooks.onUploadStart) {\n        hooks.onUploadStart()\n      }\n    }\n    xhr.onloadend = function () {\n      if (hooks.onUploadEnd) {\n        hooks.onUploadEnd()\n      }\n    }\n    xhr.onload = function () {\n\n      const { fileSize, chunkInfo } = instance\n\n      if (chunkInfo) {\n        if (chunkInfo.uploaded < fileSize) {\n          chunkInfo.uploaded += chunkInfo.uploading\n\n          if (hooks.onUploadChunkSuccess) {\n            hooks.onUploadChunkSuccess({\n              chunkIndex: chunkInfo.options.chunkIndex\n            })\n          }\n\n          // 还有分片没上传完则继续上传下一个\n          if (chunkInfo.uploaded < fileSize) {\n            chunkInfo.options.chunkIndex++\n            instance.uploadChunk(chunkInfo.options)\n            return\n          }\n        }\n      }\n\n      if (hooks.onUploadSuccess) {\n        const response = parseResponse(xhr)\n        hooks.onUploadSuccess(response())\n      }\n\n    }\n    xhr.onerror = function () {\n      if (hooks.onUploadError) {\n        hooks.onUploadError()\n      }\n    }\n    xhr.onabort = function () {\n      if (hooks.onUploadCancel) {\n        hooks.onUploadCancel()\n      }\n    }\n    // 下载文件触发的是 xhr.onprogress\n    xhr.upload.onprogress = function (event) {\n\n      const { fileSize, chunkInfo } = instance\n\n      let uploaded: number\n\n      if (chunkInfo) {\n        // 当前正在上传的分片 size\n        const chunkTotal = chunkInfo.uploading\n        // 不能比当前正在上传的 size 还大\n        const chunkUploaded = Math.min(chunkTotal, event.loaded)\n\n        if (hooks.onUploadChunkProgress) {\n          hooks.onUploadChunkProgress({\n            chunkIndex: chunkInfo.options.chunkIndex,\n            uploaded: chunkUploaded,\n            total: chunkTotal,\n            // 怕浏览器有 bug 导致 chunkTotal 为 0\n            percent: chunkTotal > 0 ? chunkUploaded / chunkTotal : 0\n          })\n        }\n\n        // 加上之前上传成功的分片 size\n        uploaded = chunkInfo.uploaded + chunkUploaded\n\n      }\n      else {\n        // 不能比文件 size 还大\n        uploaded = Math.min(fileSize, event.loaded)\n      }\n\n      if (hooks.onUploadProgress) {\n        hooks.onUploadProgress({\n          uploaded,\n          total: fileSize,\n          // 怕浏览器有 bug 导致 fileSize 为 0\n          percent: fileSize > 0 ? uploaded / fileSize : 0\n        })\n      }\n\n    }\n\n  }\n\n  /**\n   * 上传整个文件\n   */\n  upload(options: type.UploadOptions) {\n\n    const { xhr, file } = this\n\n    xhr.open('post', options.action, true)\n\n    const formData = new FormData()\n\n    for (let key in options.data) {\n      formData.append(key, options.data[key])\n    }\n\n    formData.append(options.fileName, file)\n\n    setRequestHeaders(xhr, options.headers)\n\n    xhr.send(formData)\n\n  }\n\n  /**\n   * 上传文件分片\n   */\n  uploadChunk(options: type.UploadChunkOptions) {\n\n    let { xhr, file, fileSize, chunkInfo } = this\n\n    if (!chunkInfo) {\n      chunkInfo = this.chunkInfo = {\n        uploaded: 0,\n        uploading: 0,\n        options,\n      }\n    }\n    else if (chunkInfo.options !== options) {\n      chunkInfo.options = options\n    }\n\n    // 默认从第一个分片开始上传，断点续传可以传入指定的分片\n    const chunkIndex = options.chunkIndex || 0\n    // 默认一个分片为 4M\n    const chunkSize = options.chunkSize || 4 * 1024 * 1024\n\n    const start = chunkSize * chunkIndex\n    const end = Math.min(fileSize, chunkSize * (chunkIndex + 1))\n\n    chunkInfo.uploading = end - start\n\n    xhr.open('post', options.action, true)\n\n    // xhr.setRequestHeader 必须在 open() 方法之后，send() 方法之前调用，否则会报错\n\n    // xhr.setRequestHeader 设置相同的请求头不会覆盖，而是会追加，如 key: value1, value2\n    // 这里改成覆盖\n    const headers = {\n      Range: `bytes ${start}-${end}/${fileSize}`\n    }\n\n    for (let key in options.headers) {\n      headers[key] = options.headers[key]\n    }\n\n    setRequestHeaders(xhr, headers)\n\n    xhr.send(blobSlice.call(file, start, end))\n\n  }\n\n}","import parseResponse from './parseResponse'\nimport setRequestHeaders from './setRequestHeaders'\n\nexport default function (url: string, options: RequestInit = {}) {\n  return new Promise(function (resolve, reject) {\n\n    const xhr = new XMLHttpRequest()\n\n    xhr.open(options.method || 'get', url, true)\n\n    xhr.onload = function () {\n      const response = parseResponse(xhr)\n      resolve(response())\n    }\n\n    xhr.onerror = reject\n    xhr.withCredentials = options.credentials === 'include'\n\n    setRequestHeaders(xhr, options.headers)\n\n    xhr.send(options.body || null)\n\n  })\n}"],"names":["xhr","const","keys","values","entries","getAllResponseHeaders","replace","match","key","value","push","toLowerCase","response","ok","status","statusText","url","responseURL","headers","text","responseText","json","JSON","parse","blob","Blob","clone","createResponse","let","setRequestHeader","blobSlice","File","prototype","slice","AjaxUploader","file","hooks","instance","this","fileSize","size","XMLHttpRequest","onloadstart","onUploadStart","onloadend","onUploadEnd","onload","chunkInfo","uploaded","uploading","onUploadChunkSuccess","chunkIndex","options","uploadChunk","onUploadSuccess","parseResponse","onerror","onUploadError","onabort","onUploadCancel","upload","onprogress","event","chunkTotal","chunkUploaded","Math","min","loaded","onUploadChunkProgress","onUploadProgress","support","open","action","formData","FormData","data","append","fileName","send","chunkSize","start","end","setRequestHeaders","call","Promise","resolve","reject","method","withCredentials","credentials","body"],"mappings":"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"}